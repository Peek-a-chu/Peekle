package com.peekle.domain.study.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.peekle.domain.study.dto.chat.ChatMessageRequest;
import com.peekle.domain.study.dto.chat.ChatMessageResponse;
import com.peekle.domain.study.entity.StudyChatLog;
import com.peekle.domain.study.repository.StudyChatRepository;
import com.peekle.domain.user.entity.User;
import com.peekle.domain.user.repository.UserRepository;
import com.peekle.global.redis.RedisKeyConst;
import com.peekle.global.redis.RedisPublisher;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.listener.ChannelTopic;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
@org.springframework.transaction.annotation.Transactional(readOnly = true)
public class StudyChatService {

    private final UserRepository userRepository;
    private final RedisTemplate<String, Object> redisTemplate;
    private final RedisPublisher redisPublisher;
    // private final ChatPersistenceService chatPersistenceService; // Replaced by
    // Buffer
    private final RedisChatBufferService redisChatBufferService;
    private final StudyChatRepository studyChatRepository;
    private final com.peekle.domain.study.repository.StudyRoomRepository studyRoomRepository;
    private final ObjectMapper objectMapper; // For Redis serialization

    // Redis Cache Size (Latest N messages)
    private static final int REDIS_CHAT_CACHE_SIZE = 100;

    /**
     * Send Chat (Redis Write-Through + Async DB Save)
     */
    public void sendChat(Long studyId, Long userId, ChatMessageRequest request) {
        // 0. Validate Study Room Exists (Prevent FK Violation in Bulk Insert)
        if (!studyRoomRepository.existsById(studyId)) {
            throw new IllegalArgumentException("Study Room not found: " + studyId);
        }

        // 1. Get Sender Info (Cached or DB)
        User sender = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("User not found"));

        // 2. Create Response DTO (Immediate Return)
        // Note: ID is generated by DB usually. For Redis-only phase, we might use
        // timestamp or temp ID.
        // Here we won't assign a DB ID yet.
        ChatMessageResponse response = ChatMessageResponse.builder()
                .studyId(studyId)
                .senderId(userId)
                .senderName(sender.getNickname())
                .content(request.getContent())
                .type(request.getType())
                .parentId(request.getParentId())
                .metadata(request.getMetadata())
                .createdAt(LocalDateTime.now())
                .build();

        // 3. Save to Redis List (Right Push)
        String key = String.format(RedisKeyConst.CHAT_ROOM_LOGS, studyId);
        try {
            // Serialize to JSON for consistent storage
            String json = objectMapper.writeValueAsString(response);
            redisTemplate.opsForList().rightPush(key, json);
            // Trim list to keep only latest N
            redisTemplate.opsForList().trim(key, -REDIS_CHAT_CACHE_SIZE, -1);
        } catch (Exception e) {
            log.error("Redis Push Failed", e);
        }

        // 4. Publish to Redis (Real-time)
        String topic = String.format(RedisKeyConst.TOPIC_STUDY_CHAT, studyId);
        redisPublisher.publish(new ChannelTopic(topic), com.peekle.global.socket.SocketResponse.of("CHAT", response));

        // 5. Buffer to Redis for Async Batch Persistence
        redisChatBufferService.bufferChat(response);
        // chatPersistenceService.saveChatToDB(studyId, userId, request); // Deprecated
    }

    /**
     * Get Chat History (Hybrid: Redis -> DB)
     */
    public Page<ChatMessageResponse> getChatHistory(Long studyId, Pageable pageable) {
        // If requesting the first page, try Redis first (fastest)
        if (pageable.getPageNumber() == 0) {
            String key = String.format(RedisKeyConst.CHAT_ROOM_LOGS, studyId);
            Long size = redisTemplate.opsForList().size(key);

            if (size != null && size > 0) {
                // Get latest messages from Redis (List is ordered by insertion time)
                // We want Descending order for UI (Latest first)? Or Ascending?
                // Typically history API returns page 0 as "Latest items".
                // Redis List: [Oldest ... Newest]
                // We need to reverse it or fetch from end.

                int pageSize = pageable.getPageSize();
                long start = Math.max(0, size - pageSize);
                long end = size - 1;

                List<Object> redisLogs = redisTemplate.opsForList().range(key, start, end);
                if (redisLogs != null) {
                    List<ChatMessageResponse> fastList = redisLogs.stream()
                            .map(obj -> {
                                try {
                                    return objectMapper.readValue(obj.toString(), ChatMessageResponse.class);
                                } catch (Exception e) {
                                    return null;
                                }
                            })
                            .filter(java.util.Objects::nonNull)
                            .collect(Collectors.toList());

                    // Reverse to show newest first for Page 0
                    Collections.reverse(fastList);

                    if (fastList.size() >= pageSize) {
                        return new PageImpl<>(fastList, pageable, size + 1000); // Approximate total
                    }
                }
            }
        }

        // Fallback or older pages: DB Query
        Page<StudyChatLog> dbPage = studyChatRepository.findAllByStudyIdOrderByCreatedAtDesc(studyId, pageable);
        return dbPage.map(ChatMessageResponse::from);
    }
}
