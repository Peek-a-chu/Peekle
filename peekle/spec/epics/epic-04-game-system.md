# Epic-04: 게임 시스템 (Game System)

## 📌 Overview
이 문서는 **게임 시스템**에 대한 전체 에픽 및 스토리 세부 내역을 제공합니다. 사용자는 로비에서 게임을 선택하고, 세밀한 설정으로 게임을 생성하며, 실시간 경쟁을 펼칩니다.

## 📋 Stories

### 04.1. 게임 로비 & 필터 (Frontend)
**User Story**
> **사용자**로서, **필터를 사용하여 이용 가능한 게임 방을 탐색**하고 싶다.
> 내 티어 수준과 선호하는 모드(개인/팀, 아이템 등)에 맞는 방을 찾기 위함이다.

**✅ Acceptance Criteria**
- [ ] **[게임 모드 탭/필터]** 상단에 4가지 게임 모드 버튼이 있어야 한다:
    - [ ] 개인전/타임어택, 개인전/스피드, 팀전/타임어택, 팀전/스피드
    - [ ] 각 버튼 하단에 간단한 모드 설명 텍스트가 있어야 한다.
    - [ ] 버튼 클릭 시 필터링되며, 재클릭(Toggle) 시 전체 모드로 복귀해야 한다.
- [ ] **[상태 필터]** "전체", "대기중", "진행중"을 선택하는 별도의 필터가 있어야 한다.
- [ ] **[게임 룸 리스트]** 다음 두 종류의 방이 표시되어야 한다:
    1. 현재 "대기 중(Waiting)"인 모든 공개 방
    2. 내가 "참여 중(Playing/Waiting)"인 방 (재접속용)
- [ ] **[방 카드 정보]** 각 카드에는 다음 정보가 포함되어야 한다:
    - [ ] 방 제목, 게임 모드, 인원 현황(현재/최대), 설정 시간, 문제 수
    - [ ] 방장 아이콘 및 닉네임, 현재 참여자들의 아이콘 목록
    - [ ] 잠금 아이콘(비밀번호 방인 경우), 상태 배지(대기중/진행중)
- [ ] **[입장 프로세스]**
    - [ ] 비밀번호 방 클릭 시 입력 모달이 떠야 한다.
    - [ ] 일반 방 클릭 시 즉시 대기실로 입장해야 한다.

**🛠 Implementation Tasks**
- [ ] `GameLobby` 페이지 레이아웃 및 필터 로직 구현
- [ ] `RoomCard` 컴포넌트 구현
- [ ] 방 목록 조회 API (`GET /api/v1/games`) 파라미터 설계 (`type`, `status`)
- [ ] 비밀번호 검증 및 입장 API 연동

### 04.2. 게임 생성 모달 (Frontend)
**User Story**
> **사용자**로서, **3단계 탭을 통해 상세하게 게임을 설정하고 생성**하고 싶다.
> 내가 원하는 난이도와 규칙으로 맞춤형 게임을 즐기기 위함이다.

**✅ Acceptance Criteria**
- [ ] **[탭 1: 방 정보 설정]**
    - [ ] 방 제목 입력 필드가 있어야 한다.
    - [ ] 공개/비공개 토글이 있으며, 비공개 선택 시 비밀번호 입력란이 활성화되어야 한다.
- [ ] **[탭 2: 게임 정보 설정]**
    - [ ] 게임 모드 선택 (개인/팀, 타임어택/스피드)
    - [ ] 최대 인원 설정 (슬라이더)
    - [ ] 제한 시간 설정 (타임어택 모드일 경우 활성화)
    - [ ] 문제 수 설정 (슬라이더)
- [ ] **[탭 3: 문제 출제 범위 설정]** 다음 두 가지 방식 중 하나를 선택해야 한다:
    - [ ] **BOJ 랜덤:**
        - [ ] 티어 범위 슬라이더 (예: Silver 5 ~ Gold 1)
        - [ ] 알고리즘 태그 체크박스 (다중 선택 가능)
    - [ ] **문제집 선택:**
        - [ ] 문제집 검색 기능 제공
        - [ ] "내 북마크 문제집" 목록 제공 및 선택 가능

**🛠 Implementation Tasks**
- [ ] `GameCreationModal` 및 다단계 탭(Stepper) UI 구현
- [ ] `RangeSlider` 컴포넌트 구현 (티어 선택용)
- [ ] 문제집 검색 및 북마크 조회 API 연동

### 04.3. 게임 상태 관리 (Backend)
**User Story**
> **시스템**으로서, **게임 방의 생명주기(State Machine)를 관리**하고 싶다.
> 모든 참여자의 게임 상태(대기 -> 카운트다운 -> 게임 중 -> 종료)를 동기화하기 위함이다.

**✅ Acceptance Criteria**
- [ ] 방 생성 시 상태는 `WAITING`이어야 한다.
- [ ] 방장이 시작 버튼을 누르면 카운트다운 후 `PLAYING` 상태로 전환되어야 한다.
- [ ] `GAME_START` 이벤트 브로드캐스트 시 모든 클라이언트가 게임 화면으로 전환되어야 한다.

**🛠 Implementation Tasks**
- [ ] `GameStatus` Enum 및 State Machine 로직 구현
- [ ] 상태 변경 시 Redis Pub/Sub 메시지 발행 로직
- [ ] 동시성 제어를 위한 락(Lock) 처리

### 04.4. 게임 룸 대기 공간 (Game Room Waiting) (Frontend)
**User Story**
> **참여자(방장/유저)**로서, **게임 시작 전 대기실에서 소통하고 준비 상태를 관리**하고 싶다.
> 팀전일 경우 팀을 전략적으로 선택하고, 모든 인원이 준비된 상태에서 공정하게 게임을 시작하기 위함이다.
> 또한, 친구를 쉽게 초대하여 함께 게임을 즐기고 싶다.

**✅ Acceptance Criteria**
**[공통 기능]**
- [ ] **[방 설정 확인]** 현재 방의 설정(모드, 시간, 문제 수 등)을 확인할 수 있어야 한다.
- [ ] **[참여자 목록]** 현재 방에 접속한 모든 참여자의 목록과 상태(준비/대기)를 볼 수 있어야 한다.
- [ ] **[채팅]** 대기실 내 참여자들과 실시간 채팅을 할 수 있어야 한다.
- [ ] **[초대하기]** 상단의 "초대하기" 버튼 클릭 시 게임 방 링크가 클립보드에 복사되어야 한다.

**[유저 - 공통]**
- [ ] **[준비/취소]** "준비(Ready)" 버튼을 눌러 게임 준비 상태로 전환하거나, 다시 눌러 취소할 수 있어야 한다.

**[유저 - 팀전 모드]**
- [ ] **[팀 선택/이동]** 팀전(Team Mode)일 경우, 원하는 팀(Red/Blue 등)의 빈 슬롯을 클릭하여 자유롭게 팀을 변경/이동할 수 있어야 한다.

**[방장(Host)]**
- [ ] **[게임 시작]** 방장을 제외한 모든 인원이 "준비 완료" 상태일 때만 "게임 시작" 버튼을 눌러 게임을 시작할 수 있다.

**🛠 Implementation Tasks**
- [ ] `WaitingRoom` 레이아웃 구현 (설정 패널, 참여자 리스트, 채팅창, 초대 버튼)
- [ ] `TeamSlot` 컴포넌트 및 팀 이동 로직 (팀전일 경우 활성화)
- [ ] `ChatBox` 컴포넌트 및 Socket.io 채팅 이벤트 연동
- [ ] 초대 링크 복사 기능 (`navigator.clipboard`) 구현
- [ ] 유저 Ready/Unready 상태 관리 로직
- [ ] 방장 Start 버튼 활성/비활성 검증 로직

### 04.5. 게임 플레이 화면 (Game Play Screen) (Frontend)
**User Story**
> **플레이어**로서, **최적화된 IDE 환경에서 문제를 선택하여 풀이**하고 싶다.
> 스터디룸과 유사한 편리한 코딩 환경을 제공받되, 경쟁에 집중할 수 있도록 외부 요소(남의 코드 보기 등)는 제한되기를 원한다.

**✅ Acceptance Criteria**
**[좌측 패널: 문제 목록]**
- [ ] **[문제 리스트]** 현재 게임에 출제된 문제 목록이 표시되어야 한다.
- [ ] **[상태 표시]** 각 문제는 '미해결', '성공' 상태가 아이콘으로 구분되어야 한다.
- [ ] **[선택 및 이동]**
    - [ ] 문제 클릭 시 해당 문제의 코딩 컨텍스트(IDE 탭 등)로 전환되어야 한다.
    - [ ] "문제 보기" 버튼 클릭 시 백준의 해당 문제 페이지가 새 탭으로 열려야 한다.

**[중앙 패널: IDE]**
- [ ] **[언어 선택]** C++, Python, Java, JavaScript 등 원하는 언어를 선택할 수 있어야 한다.
- [ ] **[에디터 기능]** VS Code와 유사한 경험(자동완성, 구문 강조)을 제공해야 한다 (Monaco Editor 권장).
- [ ] **[컨텍스트 유지]** 문제 A를 풀다가 문제 B로 전환해도, 문제 A에 작성하던 코드는 유지되어야 한다.
- [ ] **[제한 사항]** 스터디룸과 달리 **'남의 코드 보기'** 및 **'댓글/채팅'** 기능은 이 화면에서 제공되지 않거나 제한되어야 한다.

**🛠 Implementation Tasks**
- [ ] `GamePlayLayout` 구현 (Left: List, Center: IDE)
- [ ] `IDEContainer` 컴포넌트 재사용 (스터디룸 `Center Panel` 참조하되 기능 토글 처리)
- [ ] 문제별 코드 상태 관리 (`Recoil` or `Zustand` store: `{ problemId: code }`)
- [ ] Monaco Editor 언어 설정 연동

### 04.6. 스코어보드 & 타이머 (Frontend)
**User Story**
> **플레이어**로서, **실시간 점수와 남은 시간**을 보고 싶다.
> 현재 순위를 파악하여 전략적(속도 vs 정확도)으로 플레이하기 위함이다.

**✅ Acceptance Criteria**
- [ ] 상단에 서버 시간과 동기화된 남은 시간이 카운트다운되어야 한다.
- [ ] 누군가 점수를 획득하면 스코어보드가 즉시 갱신되고 재정렬되어야 한다.
- [ ] 점수 정렬 기준은 1순위 점수(내림차순), 2순위 달성 시간(오름차순)이어야 한다.

**🛠 Implementation Tasks**
- [ ] 시간 동기화 훅 (`useServerTime`) 구현
- [ ] `Scoreboard` 컴포넌트 및 리스트 애니메이션 적용

### 04.6. 제출 검증 (Webhook) (Backend)
**User Story**
> **시스템**으로서, **브라우저 확장 프로그램으로부터 풀이 신호**를 받고 싶다.
> 사용자가 백준에서 실제 문제를 해결했음을 검증하고 점수를 부여하기 위함이다.

**✅ Acceptance Criteria**
- [ ] 확장 프로그램의 요청 헤더(토큰)를 검증하여 유효한 사용자인지 확인해야 한다.
- [ ] 제출된 문제 ID가 현재 진행 중인 게임의 목표 문제와 일치하는지 확인해야 한다.
- [ ] 유효한 풀이일 경우 **게임 모드에 따른 점수**를 계산하여 반영해야 한다.
    - [ ] **[개인전]** 상대적 순위 배점: `(전체 인원 - 내 등수 + 1) * 10점`
    - [ ] **[팀전]** 승패 배점: 승리 팀원 각 `30점`, 패배 팀원 각 `10점` (게임 종료 시 일괄 적용 가능)
- [ ] 점수 획득 시 이벤트를 발행하여 클라이언트 스코어보드를 갱신해야 한다.

**🛠 Implementation Tasks**
- [ ] 제출 검증 API (`POST /api/games/submit`) 구현
- [ ] **점수 계산 전략(Strategy Pattern) 구현**
    - [ ] `IndividualScoreStrategy`: `(N - Rank + 1) * 10`
    - [ ] `TeamScoreStrategy`: Win `30`, Lose `10`
- [ ] 보안 인터셉터 구현

### 04.7. 제출 흐름 (Frontend)
**User Story**
> **플레이어**로서, **코드를 제출하고 즉각적인 피드백**을 받고 싶다.
> 점수 획득 여부를 바로 확인하고 다음 행동을 결정하기 위함이다.

**✅ Acceptance Criteria**
- [ ] 에디터의 "제출" 버튼 클릭 시 코드가 클립보드에 복사되고 백준 페이지로 이동하거나 연동되어야 한다.
- [ ] 서버로부터 "정답(SUCCESS)" 메시지를 받으면 화면에 축하 이펙트/토스트가 나타나야 한다.
- [ ] "오답(FAIL)"인 경우 재시도를 독려하는 메시지가 떠야 한다.

**🛠 Implementation Tasks**
- [ ] 제출 버튼 핸들러 및 클립보드 복사 로직
- [ ] 소켓 메시지 리스너(`GAME_RESULT`) 및 Toast UI 구현

### 04.8. Redis 게임 캐시 (Backend)
**User Story**
> **시스템**으로서, **활성 게임 상태를 Redis에 저장**하고 싶다.
> 빈번한 점수 업데이트 트래픽을 처리하고 DB 부하를 최소화하기 위함이다.

**✅ Acceptance Criteria**
- [ ] 게임 진행 중의 점수 및 상태는 Redis(`ZSet`, `Hash`)에서 읽고 써야 한다.
- [ ] 게임 종료 시 Redis의 최종 결과 데이터를 MySQL(`POINT_LOGS` 등)로 영구 저장(Flush)해야 한다.

**🛠 Implementation Tasks**
- [ ] Redis 데이터 구조 설계 (`game:room:{id}:scores`)
- [ ] Write-Back(지연 쓰기) 또는 종료 시점 저장 로직 구현
- [ ] TTL 설정

### 04.9. 게임 결과 모달 (Frontend)
**User Story**
> **플레이어**로서, **게임이 끝난 후 최종 결과**를 보고 싶다.
> 최종 승자, 획득한 포인트, 변경된 내 랭킹 정보를 확인하기 위함이다.

**✅ Acceptance Criteria**
- [ ] 게임 종료 이벤트 수신 시 결과 모달이 오버레이되어야 한다.
- [ ] 1, 2, 3등 사용자에게는 특별한 강조 효과(메달 등)가 있어야 한다.
- [ ] 이번 게임으로 획득한 포인트와 변동된 티어 정보가 표시되어야 한다.

**🛠 Implementation Tasks**
- [ ] `GameResultModal` 컴포넌트 구현
- [ ] 결과 애니메이션(Confetti 등) 적용